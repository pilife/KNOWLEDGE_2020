1. **进程和线程的区别？**
   
   1. 在内存中的模型分别是什么样的
   2. 创建系统调用：fork，vfork，clone
      1. fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 
      2. fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。
   
   3. 内核线程，轻量级进程，用户线程的区别：
   
      - 内核线程
        内核线程只运行在内核态，不受用户态上下文的拖累。
   
        - 处理器竞争：可以在全系统范围内竞争处理器资源；
        - 使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间
        - 调度：调度的开销可能和进程自身差不多昂贵
        - 同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。
   
      - 轻量级进程
        轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。
   
        轻量级进程由<u>clone()系统调用创建</u>，参数是CLONE_VM，<u>即与父进程是共享进程地址空间和系统资源。</u>
   
        与普通进程区别：LWP只有一个最小的执行上下文和调度程序所需的统计信息。
   
        - 处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源
        - 使用资源：与父进程共享进程地址空间
        - 调度：像普通进程一样调度
   
      - 用户线程
        用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。
   
        - 处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。
   
        - 使用资源：与所属进程共享进程地址空间和系统资源。
   
        - 调度：由在用户空间实现的线程库，在所属进程内进行调度
   
          
2. **进程间通信（IPC）**
   
   1. mmap（共享内存）：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
   
   2. 信号量：不能传递复杂消息，只能用来同步
   
   3. 管道：速度慢，容量有限，只有父子进程能通讯
   
   4. 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
   
   5. socket：可用于不同机器间的进程通信
   
      

3. **Linux特殊进程：**
   - idle进程(PID=0)：由系统自动创建, 运行在内核态。完成加载系统后，演变为<u>进程</u>调度、交换
   - init进程(PID=1)：由idle通过kernel_thread创建，完成系统的初始化. 是系统中所有其它<u>用户进程</u>的祖先进程。Linux中的所有进程都是有init进程创建并运行的。首先Linux内核启动，然后在用户空间中启动init进程，再启动其他系统进程。在系统启动完成完成后，init将变为守护进程监视系统其他进程。
   - kthreadd(PID=2)：由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有<u>内核线程</u>的调度和管理 

